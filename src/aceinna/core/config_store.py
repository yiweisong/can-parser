import jsonimport osfrom typing import List, Dictfrom dataclasses import asdictfrom ..models.convertor import Convertorfrom ..models.fetch_rule import DataSourceFetchRulefrom ..models.data_source import CommonCANDataSource, J1939DataSource, MessageMapping, FieldSettingfrom ..models.convert_rule import PlotRule, DataListRule, AxisBinding, DataListField# Helper to serialize/deserialize complex nested objectsclass ConfigStore:    def __init__(self, config_file='config.json'):        self.config_file = config_file        self.convertors: List[Convertor] = []        self.fetch_rules: List[DataSourceFetchRule] = []        self.load()    def load(self):        self.load_from_file(self.config_file)    def load_from_file(self, path: str):        if not os.path.exists(path):            return                with open(path, 'r') as f:            try:                data = json.load(f)                self.convertors = [self._dict_to_convertor(c) for c in data.get('convertors', [])]                self.fetch_rules = [self._dict_to_fetch_rule(r) for r in data.get('fetch_rules', [])]            except Exception as e:                print(f"Failed to load config from {path}: {e}")    def save(self):        self.save_to_file(self.config_file)    def save_to_file(self, path: str):        data = {            'convertors': [asdict(c) for c in self.convertors],            'fetch_rules': [asdict(r) for r in self.fetch_rules]        }        with open(path, 'w') as f:            json.dump(data, f, indent=4)    def _dict_to_convertor(self, d: Dict) -> Convertor:        # Reconstruct objects from dict (since dataclasses generic init might not handle nested conversion automatically)        c = Convertor(name=d['name'], result_folder=d.get('result_folder', ''))                # Restore Data Source        ds_data = d.get('data_source')        if ds_data:            if ds_data['type'] == 'common_can':                ds = CommonCANDataSource(                    name=ds_data.get('name', ''),                    dbc_file_path=ds_data.get('dbc_file_path', ''),                    message_mappings=[self._dict_to_message_mapping(m) for m in ds_data.get('message_mappings', [])]                )                c.data_source = ds            elif ds_data['type'] == 'j1939':                ds = J1939DataSource(                    name=ds_data.get('name', ''),                    dbc_file_path=ds_data.get('dbc_file_path', ''),                    pgn_mappings=[self._dict_to_message_mapping(m) for m in ds_data.get('pgn_mappings', [])],                    source_address_filters=ds_data.get('source_address_filters', [])                )                c.data_source = ds                # Restore Convert Rules        rules_data = d.get('convert_rules', [])        for rd in rules_data:            if rd['type'] == 'plot':                rule = PlotRule(                    title=rd.get('title', ''),                    figure_figsize=tuple(rd.get('figure_figsize', (6.4, 4.8))),                    figure_dpi=rd.get('figure_dpi', 160),                    grid_linestyle=rd.get('grid_linestyle', '--'),                    grid_alpha=rd.get('grid_alpha', 0.5),                    tick_labelsize=rd.get('tick_labelsize', 8),                    legend_label=rd.get('legend_label', 'legend1'),                    legend_loc=rd.get('legend_loc', 'best'),                    legend_fontsize=rd.get('legend_fontsize', 8)                )                if rd.get('x_axis'):                    rule.x_axis = AxisBinding(binding=rd['x_axis']['binding'])                if rd.get('y_axes'):                    rule.y_axes = [AxisBinding(binding=yb['binding']) for yb in rd['y_axes']]                c.convert_rules.append(rule)            elif rd['type'] == 'data_list':                rule = DataListRule(                    delimiter=rd.get('delimiter', ','),                    include_header=rd.get('include_header', True)                )                if rd.get('fields'):                    rule.fields = [DataListField(binding=f['binding']) for f in rd['fields']]                c.convert_rules.append(rule)                        return c    def _dict_to_message_mapping(self, m: Dict) -> MessageMapping:        mm = MessageMapping(identifier=m['identifier'])        mm.fields = [self._dict_to_field_setting(f) for f in m.get('fields', [])]        return mm    def _dict_to_field_setting(self, f: Dict) -> FieldSetting:        return FieldSetting(            name=f['name'],            start_bit=f['start_bit'],            length=f['length'],            byte_order=f.get('byte_order', 'little_endian'),            value_type=f.get('value_type', 'unsigned'),            factor=f.get('factor', 1.0),            offset=f.get('offset', 0.0),            unit=f.get('unit', '')        )    def _dict_to_fetch_rule(self, r: Dict) -> DataSourceFetchRule:        # Assuming FetchRule is flat dataclass        return DataSourceFetchRule(**r)